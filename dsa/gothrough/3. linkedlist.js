/*

fast and slow method fast !== null fast.next !== null
Middle of a LinkedList [TortoiseHare Method]

too easy 
Reverse a LinkedList [Iterative]

too easy
Reverse a LL [Recursive]

fast and slow pointer where they meet
Detect a loop in LL

find length of loop and then move one pointer from start to the length of the loop then keep on pointer on start and move the cur and start pointer one by one till they meet
Find the starting point in LL

fast and slow pointer
Length of Loop in LL

find mid and then reverse and check
Check if LL is palindrome or not

this is easy
Segrregate odd and even nodes in LL


better =  find length and delete the node
optimal = fast and slow move fast n time then move fast and slow togethere
Remove Nth node from the back of the LL

fast and slow pointer
Delete the middle node of LL

merge sort
Sort LL

brute = get the count of 0, 1, 2 and in next traversal start setting the value
OPTIMAL = easy you were able to figure out
Sort a LL of 0's 1's and 2's by changing links


brute = traversing both list + hashing
optiml = this has one memeriosed solutino that you know start trversing both node than finish move the ponter of first to second
Find the intersection point of Y LL

better: reverse
optioml: recursion
Add 1 to a number represented by LL

keep a dummy node -1 and keep  cur node to traverse
Add 2 numbers in LL

revres algo	
Reverse LL in group of given size K

point the end node to start
traver lenght - k time and make the node.next as head and point node.next to null 
Rotate a LL

esy use queue
Flattening of LL

brute => use hashmap like in hashmap 
optimal => make chain of two list like 1 -> 1 -> 2 -> 2 -> 3 -> 3
Clone a Linked List with random and next pointer







*/