/*


max at top is always complete binary tree
parent i / 2 | left child  2 * i | right 2 * i + 1
it is represented in array from 1

Insert in last index and compare above

delte the first node bring the last node to first and then start comparing from above
in heap only root node is deleted


can be done using min heap, quick select
Kth largest element in an array [use priority queue]

max heap
Kth smallest element in an array [use priority queue]

this is very easy   
min heap just keep the next k element in min heap
Sort K sorted array

min heap of (value, node)
Merge M sorted Lists

use min priority queue and store (value and index)
Replace each array element by its corresponding rank

process the most frequent character first
your solutoin hash map
optimal can be done using max heap and queue
see needtcode video
Task Scheduler

use haspmap [value, count] and min heap
Hands of Straights

	
Design twitter

optimal => take two small rope and add them then again take two small rope and add them
Connect `n` ropes with minimal cost


Kth largest element in a stream of running integers


Maximum Sum Combination


Find Median from Data Stream

brute = hashmap and max heap
optimal = bucket sort
K most frequent elements


******************** fuckedup question **********************

quick select 
job schedular
bucket sort



*/