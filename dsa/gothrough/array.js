/*


don't need to solve
Largest Element in an Array

don't need to solve
Second Largest Element in an Array without sorting

don't need to solve
Check if the array is sorted

don't need to solve
Remove duplicates from Sorted array

don't need to solve
Left Rotate an array by one place

don't need to solve
Left rotate an array by D places

don't need to solve
Move Zeros to end

don't need to solve
Find the Union

don't need to solve
Find missing number in an array

sliding window
Maximum Consecutive Ones

better: hashing
optimal: sum all the number
Find the number that appears once, and other numbers twice.

better: hashing
here there is edge case with zero suppose the array is [2, 0, 0, 3] your answer will be index 3 to 3 but it is 1 to 3 just remember the edge case solution is easy
optimal:  can be done using sliding window
Longest subarray with given sum K(positives)

*/

/*


better: hasing
optimal: two pointer
2Sum Problem

this you have done many time using mid
Sort an array of 0's 1's and 2's

better: hashing
optimal: moore algorithm
Majority Element (>n/2 times)

Kadane's Algorithm, maximum subarray sum

this you did'nt do as it is covered in dp
Stock Buy and Sell

better: can be done using an extra array
Rearrange the array in alternating positive and negative items

can be done using recursion or you can check
Next Permutation

very easy don't do it
Leaders in an Array problem


better: sort the array
optimal: use set
Longest Consecutive Sequence in an Array

this one watch striver video for optimal solution
Set Matrix Zeros

 you can find a diagonal pattern here
Rotate Matrix by 90 degrees

this was easy try one time just the theory hint four for loop for four side don't try to complicate
Print the matrix in spiral manner

using prefix sum hashmap 
Count subarrays with given sum




******************************************************
Hard

this can be solve using some alog and other by find the upper index
Pascal's Triangle

better: hashing
optimal: you know since it is n/3 there would be 2 element present which would be appearing n/3 times like if n = 8 then it would be 8/3 = 2 so 3 + 3 + 2 so 2 numbers
see the optimal solution can be solved by twiking morees solution
Majority Element (n/3 times)


this need to do
3-Sum Problem

4-Sum Problem

optimal this can be done using prefix sum
Largest Subarray with 0 Sum

Count number of subarrays with given xor K


optimal: sort by both pair
Merge Overlapping Subintervals

Merge two sorted arrays without extra space

missing number better: hash optimal: cyclic sort and maths 
you can check stiver solution once
Find the repeating and missing number

merge sort
Count Inversions

Reverse Pairs

kadn algo
Maximum Product Subarray

*/
